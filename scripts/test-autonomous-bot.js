#!/usr/bin/env node

/**
 * PRUEBA DEL BOT AUT√ìNOMO CONSOLIDADO
 *
 * Script para probar que el bot aut√≥nomo funciona correctamente
 * despu√©s de la consolidaci√≥n del sistema
 *
 * @author Ricardo Buritic√° - Asistente RB Team
 * @version 2.1.0
 */

require("dotenv").config({ path: ".env" });
require("dotenv").config({ path: ".env.local", override: true });

const axios = require("axios");

// Colores para la consola
const colors = {
  green: "\x1b[32m",
  red: "\x1b[31m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  reset: "\x1b[0m",
  bold: "\x1b[1m",
};

function log(message, color = "reset") {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSection(title) {
  console.log(`\n${colors.bold}${colors.blue}=== ${title} ===${colors.reset}`);
}

async function testEndpoint(
  url,
  method = "GET",
  data = null,
  description = ""
) {
  try {
    const config = {
      method,
      url,
      timeout: 10000,
      validateStatus: (status) => status < 500, // No fallar en 4xx
    };

    if (data) {
      config.data = data;
      config.headers = {
        "Content-Type": "application/json",
      };
    }

    const response = await axios(config);

    if (response.status >= 200 && response.status < 300) {
      log(`‚úÖ ${description}: ${response.status} - OK`, "green");
      return { success: true, status: response.status, data: response.data };
    } else {
      log(
        `‚ö†Ô∏è  ${description}: ${response.status} - ${response.statusText}`,
        "yellow"
      );
      return { success: false, status: response.status, data: response.data };
    }
  } catch (error) {
    if (error.code === "ECONNREFUSED") {
      log(`‚ùå ${description}: Servidor no est√° ejecut√°ndose`, "red");
      return { success: false, error: "ECONNREFUSED" };
    } else {
      log(`‚ùå ${description}: ${error.message}`, "red");
      return { success: false, error: error.message };
    }
  }
}

async function testAutonomousBot() {
  log(
    `${colors.bold}ü§ñ PRUEBA DEL BOT AUT√ìNOMO CONSOLIDADO${colors.reset}`,
    "blue"
  );
  log(`Timestamp: ${new Date().toISOString()}\n`);

  const baseUrl = "http://localhost:3000";
  let allTests = true;

  // ===== VERIFICAR QUE EL SERVIDOR EST√â EJECUT√ÅNDOSE =====
  logSection("VERIFICACI√ìN DEL SERVIDOR");

  const healthCheck = await testEndpoint(
    `${baseUrl}/health`,
    "GET",
    null,
    "Health Check"
  );

  if (!healthCheck.success) {
    log(
      "\n‚ùå El servidor no est√° ejecut√°ndose. Inicia el servidor con:",
      "red"
    );
    log("npm start", "yellow");
    log("\nO verifica que est√© ejecut√°ndose en el puerto 3000", "yellow");
    process.exit(1);
  }

  // Mostrar informaci√≥n del health check
  if (healthCheck.data) {
    log(`üìä Informaci√≥n del servidor:`, "blue");
    log(`   - Estado: ${healthCheck.data.status}`, "blue");
    log(`   - Versi√≥n: ${healthCheck.data.version}`, "blue");
    log(`   - Entorno: ${healthCheck.data.environment}`, "blue");
    log(`   - Uptime: ${Math.round(healthCheck.data.uptime)}s`, "blue");

    if (healthCheck.data.services) {
      log(`   - Servicios configurados:`, "blue");
      Object.entries(healthCheck.data.services).forEach(([service, status]) => {
        const icon =
          status === "configured" || status === "connected" ? "‚úÖ" : "‚ö†Ô∏è";
        log(
          `     ${icon} ${service}: ${status}`,
          status === "configured" || status === "connected" ? "green" : "yellow"
        );
      });
    }
  }

  // ===== PROBAR ENDPOINTS PRINCIPALES =====
  logSection("ENDPOINTS PRINCIPALES");

  const mainEndpoints = [
    ["/", "Ruta principal"],
    ["/api", "API informaci√≥n"],
    ["/health", "Health check"],
  ];

  for (const [endpoint, description] of mainEndpoints) {
    const result = await testEndpoint(
      `${baseUrl}${endpoint}`,
      "GET",
      null,
      description
    );
    if (!result.success && result.error !== "ECONNREFUSED") {
      allTests = false;
    }
  }

  // ===== PROBAR ENDPOINTS DEL BOT AUT√ìNOMO =====
  logSection("ENDPOINTS DEL BOT AUT√ìNOMO");

  const botEndpoints = [
    ["/api/servicios", "Servicios disponibles"],
    ["/api/whatsapp", "WhatsApp API (GET)"],
    ["/autonomous/whatsapp", "WhatsApp aut√≥nomo (GET)"],
  ];

  for (const [endpoint, description] of botEndpoints) {
    const result = await testEndpoint(
      `${baseUrl}${endpoint}`,
      "GET",
      null,
      description
    );
    if (
      !result.success &&
      result.status !== 404 &&
      result.error !== "ECONNREFUSED"
    ) {
      allTests = false;
    }
  }

  // ===== PROBAR WEBHOOKS (solo verificar que respondan) =====
  logSection("WEBHOOKS (Verificaci√≥n de Respuesta)");

  const webhookEndpoints = [
    ["/webhook/whatsapp", "WhatsApp Webhook"],
    ["/api/calendly/webhook", "Calendly Webhook"],
  ];

  for (const [endpoint, description] of webhookEndpoints) {
    const result = await testEndpoint(
      `${baseUrl}${endpoint}`,
      "GET",
      null,
      `${description} (GET)`
    );
    // Los webhooks pueden devolver 405 (Method Not Allowed) para GET, eso est√° bien
    if (result.status === 405) {
      log(
        `‚úÖ ${description}: Endpoint responde (405 Method Not Allowed es esperado)`,
        "green"
      );
    }
  }

  // ===== PROBAR SIMULACI√ìN DE MENSAJE DE WHATSAPP =====
  logSection("SIMULACI√ìN DE MENSAJE DE WHATSAPP");

  // Simular un mensaje de WhatsApp (sin validaci√≥n de firma en desarrollo)
  const whatsappMessage = {
    From: "whatsapp:+34600123456",
    To: "whatsapp:+14155238886",
    Body: "Hola, quiero reservar una cita",
    MessageSid: "test_message_" + Date.now(),
  };

  log("üîÑ Enviando mensaje de prueba al bot...", "blue");
  const whatsappTest = await testEndpoint(
    `${baseUrl}/webhook/whatsapp`,
    "POST",
    whatsappMessage,
    "Simulaci√≥n de mensaje WhatsApp"
  );

  if (whatsappTest.success) {
    log("‚úÖ El bot proces√≥ el mensaje correctamente", "green");
  } else if (whatsappTest.status === 401) {
    log(
      "‚ö†Ô∏è  Webhook requiere validaci√≥n de firma (normal en producci√≥n)",
      "yellow"
    );
  } else {
    log(
      "‚ö†Ô∏è  El bot no pudo procesar el mensaje, pero el endpoint responde",
      "yellow"
    );
  }

  // ===== PROBAR ENDPOINTS DE ADMINISTRACI√ìN =====
  logSection("ENDPOINTS DE ADMINISTRACI√ìN");

  const adminEndpoints = [
    ["/admin", "Dashboard administrativo"],
    ["/client", "Portal del cliente"],
    ["/widget", "Widget de reservas"],
  ];

  for (const [endpoint, description] of adminEndpoints) {
    const result = await testEndpoint(
      `${baseUrl}${endpoint}`,
      "GET",
      null,
      description
    );
    // Estos endpoints pueden requerir autenticaci√≥n o devolver HTML
    if (result.success || result.status === 401 || result.status === 403) {
      log(`‚úÖ ${description}: Endpoint disponible`, "green");
    }
  }

  // ===== VERIFICAR CONFIGURACI√ìN DE SERVICIOS =====
  logSection("CONFIGURACI√ìN DE SERVICIOS");

  try {
    const serviciosResult = await testEndpoint(
      `${baseUrl}/api/servicios`,
      "GET",
      null,
      "Lista de servicios"
    );

    if (serviciosResult.success && serviciosResult.data) {
      if (
        Array.isArray(serviciosResult.data) &&
        serviciosResult.data.length > 0
      ) {
        log(
          `‚úÖ Servicios cargados: ${serviciosResult.data.length} servicios disponibles`,
          "green"
        );

        // Mostrar algunos servicios de ejemplo
        const firstServices = serviciosResult.data.slice(0, 3);
        firstServices.forEach((service) => {
          log(`   - ${service.name} (‚Ç¨${service.price})`, "blue");
        });

        if (serviciosResult.data.length > 3) {
          log(
            `   ... y ${serviciosResult.data.length - 3} servicios m√°s`,
            "blue"
          );
        }
      } else {
        log("‚ö†Ô∏è  No hay servicios configurados en la base de datos", "yellow");
      }
    }
  } catch (error) {
    log(
      `‚ö†Ô∏è  No se pudo verificar la configuraci√≥n de servicios: ${error.message}`,
      "yellow"
    );
  }

  // ===== RESUMEN FINAL =====
  logSection("RESUMEN DE PRUEBAS");

  if (allTests && healthCheck.success) {
    log("üéâ TODAS LAS PRUEBAS PASARON", "green");
    log("‚úÖ El bot aut√≥nomo est√° funcionando correctamente", "green");

    log("\nüìã Estado del sistema:", "blue");
    log("‚úÖ Servidor ejecut√°ndose correctamente", "green");
    log("‚úÖ Endpoints principales respondiendo", "green");
    log("‚úÖ Bot aut√≥nomo operativo", "green");
    log("‚úÖ Webhooks configurados", "green");
    log("‚úÖ Interfaces de usuario disponibles", "green");

    log("\nüöÄ El bot est√° listo para recibir mensajes de WhatsApp!", "green");
    log("\nüì± Para probar con WhatsApp real:", "blue");
    log(
      "1. Configura el webhook de Twilio: https://tu-dominio.com/webhook/whatsapp",
      "blue"
    );
    log("2. Env√≠a un mensaje al n√∫mero de WhatsApp configurado", "blue");
    log("3. El bot responder√° autom√°ticamente", "blue");
  } else {
    log("‚ö†Ô∏è  ALGUNAS PRUEBAS FALLARON O TIENEN ADVERTENCIAS", "yellow");
    log(
      "üìã El sistema b√°sico funciona, pero revisa las advertencias anteriores",
      "yellow"
    );

    log("\nüîß Posibles acciones:", "yellow");
    log("1. Verificar configuraci√≥n de variables de entorno", "yellow");
    log(
      "2. Asegurar que todos los servicios externos est√©n configurados",
      "yellow"
    );
    log("3. Revisar logs del servidor para m√°s detalles", "yellow");
  }

  log("\nüìä URLs importantes:", "blue");
  log(`- Health Check: ${baseUrl}/health`, "blue");
  log(`- API Info: ${baseUrl}/api`, "blue");
  log(`- Dashboard Admin: ${baseUrl}/admin`, "blue");
  log(`- Portal Cliente: ${baseUrl}/client`, "blue");
  log(`- Widget Reservas: ${baseUrl}/widget`, "blue");

  process.exit(allTests ? 0 : 1);
}

// Ejecutar pruebas
testAutonomousBot().catch((error) => {
  log(`üí• Error durante las pruebas: ${error.message}`, "red");
  console.error(error);
  process.exit(1);
});
